# 第三十一章：高级主题 (3) - 创建你自己的控制智能体

上一章我们学习了如何创建自定义的 **物理模型**，本章我们将学习如何创建自定义的 **决策模型**，即 **智能体 (Agent)**。一个智能体就是一个独立的、有自己逻辑的“虚拟操作员”，它能感知系统状态，并根据内置的逻辑做出决策，发布指令。

我们将通过继承 `BaseAgent` 基类，来创建一个全新的 `HysteresisControllerAgent` (滞回控制器)，并将第二十四章中手动实现的泵站启停逻辑，封装成一个可复用的、独立的智能体组件。

## 核心概念：`BaseAgent` 接口

`BaseAgent` 为所有智能体提供了一个统一的生命周期和通信接口：

1.  **`__init__(self, agent_id, kernel, **config)`**: 构造函数。`kernel` 参数是 `Host` 的引用，让智能体可以访问消息总线等核心服务。`config` 是一个字典，用于传递自定义参数。
2.  **`setup(self)`**: 初始化设置。在所有智能体都创建完毕后，`Host` 会调用每个智能体的 `setup` 方法。这是订阅消息主题的最佳位置。
3.  **`on_message(self, message)`**: 消息处理器。当智能体订阅的主题上有新消息时，`Host` 会调用此方法。这是智能体“感知”外部世界的入口。
4.  **`execute(self, current_time, time_step)`**: 执行器。在每个仿真时间步，`Host` 都会调用此方法。这是智能体执行其内部逻辑并“行动”（发布指令）的地方。
5.  **`_publish(self, topic, payload)`**: 发布消息的辅助方法，用于向消息总线发送指令或状态。

## 场景：封装一个水泵启停控制器

我们将把第二十四章中控制水泵的 `if/else` 逻辑，封装成一个独立的 `HysteresisControllerAgent`。
*   **功能**: 监控一个水库的水位。
*   **逻辑**:
    *   当水位低于 `low_threshold` (低位阈值) 时，发布一个“开启”指令 (例如，输出1)。
    *   当水位高于 `high_threshold` (高位阈值) 时，发布一个“关闭”指令 (例如，输出0)。
    *   当水位在两者之间时，保持当前状态不变（这就是“滞回”的含义）。
*   **目标**: 创建一个通用的、可复用的控制器，可以方便地应用于任何需要启停控制的场景。

## 构建自定义智能体脚本

### 完整脚本与运行

本章的完整示例代码已保存到以下文件中：

`source/ch31/ch31_custom_agent.py`

您可以直接运行此文件来查看仿真结果。该脚本首先定义了 `HysteresisControllerAgent` 类，然后实例化该类，并将其与一个水箱和一个水泵模型组合起来，以验证其功能。

```bash
python water_system_sdk/docs/guide/source/ch31/ch31_custom_agent.py
```
*注意：为了清晰地展示智能体如何通过消息总线进行通信，该示例在主循环中“手动”模拟了消息的传递过程。在更高级的、完全基于事件的架构中，这些 `on_message` 调用将由 `Host` 的消息总线自动触发。*

### 预期结果

运行脚本后，您会看到一个与第二十四章非常相似的图表，显示了水箱水位在3.0米和8.0米之间被我们的自定义智能体成功地来回控制。

这证明我们成功地将一段特定的控制逻辑，封装成了一个独立的、可配置的、可复用的 `HysteresisControllerAgent` 智能体。您可以将这个智能体应用到任何需要滞回控制的系统中，而无需重写逻辑。这就是面向对象和智能体建模的强大之处。
